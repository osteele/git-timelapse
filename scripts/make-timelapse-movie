#!/usr/bin/env python
"""
Make timelapse movie from image frames or text or script versions.

Usage:
  make-timelapse-movie SOURCE_DIR [--frame-dir=DIR] [--linger=N] [--interpolate=N]

Options:
  -h --help        Show this screen.
  --frame-dir DIR  Store frames in this directory [default: frames].
  --linger=n       Repeat keyframe images this many times before moving on [default: 1].
  --interpolate=n  Add this many interpolation frames between keyframes [default: 0].
"""

import io
import math
import os
import re
import shlex
import shutil
from fractions import gcd
from glob import glob

import numpy
import pygments
import pygments.lexers
import pygments.formatters
from docopt import docopt
from PIL import Image, ImageChops
from schema import Schema, And, Or, Use, SchemaError
from tqdm import tqdm

WHITE = (255, 255, 255)

movie_width, movie_height = 1024, 768

def text_file_to_image(file):
    lexer = pygments.lexers.get_lexer_for_filename(file)
    formatter = pygments.formatters.get_formatter_by_name('bmp', line_numbers=False)
    with open(file) as fd:
        data = pygments.highlight(fd.read(), lexer, formatter)
    return Image.open(io.BytesIO(data))

def read_file_image(file):
    try:
        return Image.open(file)
    except OSError as e:
        if 'cannot identify image file' not in str(e):
            raise e
        return text_file_to_image(file)

def cropped(im):
    bg = Image.new(im.mode, im.size, WHITE)
    diff = ImageChops.difference(im, bg)
    bbox = diff.getbbox()
    if bbox:
        return im.crop(bbox)
    return im

def layout_image(im, cols):
    """Layout image im in multiple columns onto a new image with the same proportions."""
    source_width, source_height = im.size
    dest_frame = Image.new(im.mode, (movie_width * cols, movie_height * cols), color=WHITE)
    col_width = source_width
    col_height = dest_frame.size[1]
    source_tile_y = 0
    dest_tile_x = 0
    for col in range(cols):
        if source_tile_y > source_height and cols > 1:
            # Starting a new column while out of source material.
            # We could have gotten by with one fewer columns.
            return layout_image(im, cols - 1)
        source_bottom = min(source_tile_y + col_height, source_height)
        region = im.crop((0, source_tile_y, source_width, source_bottom))
        dest_frame.paste(region, ((dest_tile_x, 0, dest_tile_x + col_width, source_bottom - source_tile_y)))
        dest_tile_x += col_width
        source_tile_y = source_bottom
    return dest_frame

def iter_file_images(files):
    for file in files:
        im = cropped(read_file_image(file))
        w, h = im.size
        cols = math.ceil(math.sqrt(h / movie_height))
        frame = layout_image(im, cols)
        yield frame

def resize_images_to_lcm(im0, im1):
    """Resize im0 and im1 to the same size."""
    if im0.size == im1.size:
        return im0, im1
    w0, h0 = im0.size
    w1, h1 = im1.size
    assert w0 / h0 == w1 / h1
    s = w1 / gcd(w0, w1)
    w = int(s * w0)
    h = int(s * h0)
    size = (w, h)
    im0 = im0.resize(size, Image.ANTIALIAS)
    im1 = im1.resize(size, Image.ANTIALIAS)
    return im0, im1

def interpolate_frames(frames, interpolate=0, linger=1, **kwargs):
    prev_frame = None
    for frame in frames:
        if prev_frame and interpolate > 0:
            im0, im1 = resize_images_to_lcm(prev_frame, frame)
            for i in range(interpolate):
                s = i / interpolate
                ar = (1.0 - s) * numpy.asarray(im0) + s * numpy.asarray(im1)
                yield Image.fromarray(numpy.uint8(ar))
        for _ in range(linger):
            yield frame
        prev_frame = frame

def make_movie(source_dir, frame_dir='frames', interpolate=0, linger=1, **kwargs):
    shutil.rmtree(frame_dir)
    os.makedirs(frame_dir, exist_ok=True)
    files = sorted(glob(os.path.join(source_dir, '*')))
    out_count = len(files) * (interpolate + linger) - interpolate
    frame_pattern = os.path.join(frame_dir, "frame-{:03d}.tiff")
    assert out_count < 1000 # TODO adapt frame_pattern padding
    print(f"Reading {len(files)} key frames; writing {out_count} output frames")
    t = tqdm(files)
    for i, frame in enumerate((interpolate_frames(iter_file_images(t), **kwargs))):
        outfile = frame_pattern.format(i)
        t.set_postfix(out=outfile)
        frame.save(outfile)
    frame_pattern = re.sub(r'\{:(.+?)\}', r'%\1', frame_pattern)
    movie_file = "timelapse.mp4"
    os.system(f"ffmpeg -r 5 -i {shlex.quote(frame_pattern)} -pix_fmt yuv420p -y {movie_file}")

def parse_args():
    args = docopt(__doc__)
    schema = Schema({
        'SOURCE_DIR': And(os.path.exists, error='SOURCE_DIR should be a directory'),
        '--frame-dir': str,
        '--interpolate': Use(int),
        '--linger': Use(int),
    })
    try:
        args = schema.validate(args)
    except SchemaError as e:
        exit(e)
    return {re.sub(r'^--', '', k): v for k, v in args.items()}

if __name__ == '__main__':
    args = parse_args()
    make_movie(args['SOURCE_DIR'], **args)

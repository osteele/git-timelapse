#!/usr/bin/env python
"""
Make timelapse movie from image frames or text or script versions.

Usage:
  make-timelapse-movie SOURCE_DIR [--frame-dir=DIR] [--linger=N] [--interpolate=N]

Options:
  -h --help        Show this screen.
  --frame-dir DIR  Store frames in this directory [default: frames].
  --linger=n       Repeat keyframe images this many times before moving on [default: 1].
  --interpolate=n  Add this many interpolation frames between keyframes [default: 0].
"""

import io
import math
import os
import re
import shlex
import shutil
from fractions import gcd
from glob import glob

import numpy
import pygments
import pygments.lexers
import pygments.formatters
from docopt import docopt
from PIL import Image, ImageChops
from schema import Schema, And, Or, Use, SchemaError

WHITE = (255, 255, 255)

movie_width, movie_height = 1024, 768

def text_file_to_image(infile):
    lexer = pygments.lexers.get_lexer_for_filename(infile)
    formatter = pygments.formatters.get_formatter_by_name('bmp', line_numbers=False)
    with open(infile) as fd:
        data = pygments.highlight(fd.read(), lexer, formatter)
    return Image.open(io.BytesIO(data))

def read_file_image(infile):
    try:
        return Image.open(infile)
    except OSError as e:
        if 'cannot identify image file' not in str(e):
            raise e
        return text_file_to_image(infile)

def cropped(im):
    bg = Image.new(im.mode, im.size, WHITE)
    diff = ImageChops.difference(im, bg)
    bbox = diff.getbbox()
    if bbox:
        return im.crop(bbox)
    return im

def make_frame(im, cols):
    source_width, source_height = im.size
    dest_frame = Image.new(im.mode, (movie_width * cols, movie_height * cols), color=WHITE)
    col_width = source_width
    col_height = dest_frame.size[1]
    source_tile_y = 0
    dest_tile_x = 0
    for col in range(cols):
        if source_tile_y > source_height and cols > 1:
            # Starting a new column while out of source material.
            # We could have gotten by with one fewer columns.
            return make_frame(im, cols - 1)
        source_bottom = min(source_tile_y + col_height, source_height)
        region = im.crop((0, source_tile_y, source_width, source_bottom))
        dest_frame.paste(region, ((dest_tile_x, 0, dest_tile_x + col_width, source_bottom - source_tile_y)))
        dest_tile_x += col_width
        source_tile_y = source_bottom
    return dest_frame

def make_frames(files):
    for infile in files:
        im = cropped(read_file_image(infile))
        w, h = im.size
        cols = math.ceil(math.sqrt(h / movie_height))
        frame = make_frame(im, cols)
        yield frame

def resize_images_to_lcm(im0, im1):
    if im0.size == im1.size:
        return im0, im1
    w0, w1 = im0.size[0], im1.size[0]
    h0, h1 = im0.size[1], im1.size[1]
    s = w1 / gcd(gcd(w0, w1), gcd(h0, h1))
    w = int(s * w0)
    h = int(s * h0)
    size = (w, h)
    im0 = im0.resize(size, Image.ANTIALIAS)
    im1 = im1.resize(size, Image.ANTIALIAS)
    return im0, im1

def interpolate_frames(frames, *, interpolate=0, linger=1, **kwargs):
    prev_frame = None
    for frame in frames:
        if prev_frame:
            im0, im1 = resize_images_to_lcm(prev_frame, frame)
            for i in range(interpolate):
                s = i / interpolate
                ar = (1.0 - s) * numpy.asarray(im0) + s * numpy.asarray(im1)
                yield Image.fromarray(numpy.uint8(ar))
        for _ in range(linger):
            yield frame
        prev_frame = frame

def convert(source_dir, frame_dir='frames', **kwargs):
    shutil.rmtree(frame_dir)
    os.makedirs(frame_dir, exist_ok=True)
    files = sorted(glob(os.path.join(source_dir, '*')))
    for i, frame in enumerate(interpolate_frames(make_frames(files), **kwargs)):
        outfile = os.path.join(frame_dir, "frame-{:03d}.tiff".format(i))
        print('Writing', outfile)
        frame.save(outfile)
    os.system(f"ffmpeg -r 5 -i {shlex.quote(os.path.join(frame_dir, 'frame-%03d.tiff'))} -pix_fmt yuv420p -y timelapse.mp4")

if __name__ == '__main__':
    args = docopt(__doc__)
    schema = Schema({
        'SOURCE_DIR': And(os.path.exists, error='SOURCE_DIR should be a directory'),
        '--frame-dir': str,
        '--interpolate': Use(int),
        '--linger': Use(int),
    })
    try:
        args = schema.validate(args)
    except SchemaError as e:
        exit(e)
    args = {re.sub(r'^--', '', k): v for k, v in args.items()}
    convert(args['SOURCE_DIR'], **args)
